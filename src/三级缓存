三级缓存
首先自己回答几个问题：
1、必须使用三级缓存才能完成功能吗？
2、三级缓存都有哪三级？分别都缓存什么？
3、三级缓存的原理？
4、两级缓存可不可行？


问题1
答：不是必须使用三级缓存，循环依赖的场景一共分为三种：
场景一：
A 依赖 B
B 依赖 A
场景二：
A 依赖 B
B 依赖 C
C 依赖 A
场景三：
A 依赖 A

假定使用1级缓存，只要遇见创建Bean的场景就将未属性注入，也就是半成品的Bean放入缓存即可解决：
对于场景1：
A 创建Bean完成后就放入缓存，然后属性注入的时候需要B，发现B没有那么就创建B，创建完B就放入缓存，B在属性注入的时候从缓存拿到A，那么注入完成，
随后A也可以注入完成，完结撒花🎉。

对于场景3：
A 创建Bean完成后就放入缓存，然后依赖自己的时候就直接可以从缓存中获取了，完结撒花🎉。

对于场景2：
A 创建Bean放入缓存 ，依赖B发现B没有那么就创建B并且放入缓存，B依赖C发现C没有创建C放入缓存，C依赖A但是缓存中有，那么C创建成功，进而B属性注入
成功，B创建成功，最后A属性注入成功，进而A创建成功，完结撒花🎉。

    但是为什么Spring没有采用上面的设计方案呢？其实主要有两个问题，第一是一级缓存的职责不清楚，一级缓存不便与扩展。二是一级缓存没办法解决代理
的Bean的循环依赖的问题，因为我们的代理对象是需要在属性注入后才能实例化处代理对象的（这是Spring在Bean的生命周期中的嵌入策略，这样就和一级
缓存的解决方式矛盾了，因为代理对象的创建成功必须在属性注入之后，而注入的成功必须让代理对象的创建前置。）有的人可能有疑问，为啥代理对象Bean的
创建需要在属性注入之后？这是因为如果放在属性注入之前，那么代理对象就无法完成属性注入了，（这块存在疑问，稍后自己尝试一下，放在前面，然后让代理
Bean执行后续的属性注入阶段，看看会出现什么问题）
    因此总结而言一级缓存已经可以解决简单场景（排除代理）的循环依赖问题，而为了解决代理对象的循环依赖问题其实二级依赖就可以了，我们可以想象这么
一个策略，

（想一个二级缓存的解决策略，这块还是有点不清楚！！）

问题2
答：分别是成品Bean的缓存，也就是正常的单例Bean的HashMap，二级缓存是半成品的Bean的Map，也就是没有完成属性注入的Bean，三级缓存就是FactoryBean
的HashMap缓存。

问题3
答：核心原理就是将遇见的Bean提前暴露出来，然后后置的将属性注入。
